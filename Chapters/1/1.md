# Chapter 1: Type System Fundamentals

## 1.1 Reference and Value Types

A type, in general, is a description of a set of values<sup>1</sup>. A value is a meaningless sequence of bits. When a value is associated with a type, the value becomes meaningful. In other words, a type describes the meaning of these bits and provides operations that manipulate these bits accordingly. For example, when some value is said to be of type **System.Int32** , it means that the value has 32 bits representing a singed integer in the two&#39;s complement format. Types are crucial for writing correct, understandable code. If some code interpreted these 32 bits as a floating-point number, you would have a bug that is difficult to detect. When you explicitly state that a value is of type **System.Int32** , compilers and runtimes can make sure that it&#39;s always used correctly, as a **System.Int32** value. A value described by a type is called an _instance_ of that type.

Each value is an instance of at least one type where exactly one of these types fully describes that value. For example, an instance of **System.Object** has one type that fully describes it. An instance of **System.String** is also an instance of the parent type **System.Object**. However, in this case, **System.String** is called the _exact type_ or the _run-time type_ of the instance because it fully describes bits of the value and all the operations that can be performed on it. On the other hand, **System.Object** is a partial description of the value.

The Common Type System (CTS) defines two kinds of types: value types and reference types. Moreover, the CTS defines three kinds of reference types: object types, interface types, and pointer types. However, when people say &quot;reference types,&quot; they usually mean object types and interface types only. In fact, this is how reference types are defined in C#<sup>2</sup>. Therefore, it&#39;s important while reading this book (or any other related material) to recognize from the context whether CTS reference types or C# reference types are being discussed. I will define and discuss reference and value types in detail and provide some guidelines that help you determine whether to use a value type or a reference type.

A _reference type_ is a type whose instances are either accessed indirectly through another value called a reference or references themselves. A value type is a type whose instances are accessed directly without using references. An instance of a value type is called a _value_. This is yet another definition of the term value. These definitions imply that instances of reference and value types have different copy semantics. As illustrated later in this chapter, reference types have copy-by-reference semantic while value types have copy-by-value semantic.

An _object type_is a reference type whose instances have the following two properties:

- _Self-describing_: By looking at the bits of an instance, the exact type of the instance can be determined. Instances of object types are called _objects_. This is required to support polymorphism.
- _Identifiable_: Objects have identities. An _identity_ is a value that can be used to access the object. In fact, the only way to access an object is by using its identity. An identity is different from a pointer. A _pointer_ is simply an address of a memory location. If the value stored in that location has been moved to another location, then that pointer will no longer point to the same value. On the other hand, the identity of an object remains valid even if the location of object has changed and as long as the object is alive. As a programmer, you should not care about how an identity is implemented and you should think of it as an opaque value. The C# standard specifies that identities can be read or written atomically. The CLI, however, specifies that only properly-aligned identities can be accessed atomically. I&#39;ll talk more about thread-safety issues later in this book.

A _pointer type_ is a reference type whose instances are pointers. A _reference_ is either an identity of an object or a pointer. An _interface type_ is a reference type that describes some of the behavior of its instances and none of the representation. Therefore, interface types cannot be exact types. Object types and interface types are discussed in detail in Chapter 2.

When using instances of reference types, you will be working with variables that contain references to access the instances. On the other hand, a variable of a value type directly contains the instance. Examples of reference types include: **System.String** , **System.Random** , **System.Collections.BitArray** , and **System.Collections.Generic.List\&lt;T\&gt;**. Examples of value types include: **System.Int32** , **System.Int64** , **System.Double** , and **System.DateTime**.

### 1.1.1 The Need for two Kinds of Types

Consider the following line of C# code, which creates an instance of the **BitArray** reference type:

```
BitArray array = new BitArray(32); // A bit array with 32 bits.
```

When the **new** operator executes, an instance of type **BitArray** is allocated somewhere in memory and a value that identifies this instance is stored in the **array** variable, which itself it stored somewhere else in memory. The **array** variable holds only the reference to the instance; the instance itself is a separate value stored in a different location. Typically, the **array** variable is small in size (such as 32 or 64 bits). Since **array** is a variable in itself, it must have a type. It&#39;s the type of object identities. This type is hidden from you in C#. You have to go down to the level of CIL to see it. When people refer to **array** as an object, they&#39;re usually talking about the object identified by **array**.

The fact that the **array** variable contains a reference to the **BitArray** object is crucial for being able to write structural code. This enables us to split the total functionality of a program into methods. If you passed the **array** variable to a method, it will be able to change the object because it has a reference to the object (it knows its identity). If **BitArray** was a value type, passing the **array** variable to a method means that the method will get a copy of the instance and so any modifications performed on that copy, the instance held by the **array** variable will not be affected. When a method gets a copy of a reference, it can access the same object.

So if reference types are so important, why do we need value types? Although you could build a framework that only has reference types, its performance would be terrible. To see this, let&#39;s assume that all types are reference types. In particular, let&#39;s assume for a moment that **Int32** is a reference type. In this way, all instances can only be accessed indirectly though their references. Therefore, more machine instructions and more memory accesses are needed to access instances. Clearly, this overhead is going to deteriorate performance. In addition, such hypothetical framework would make programs consume more memory. The following code creates an array of 100 **Int32** values:

```
Int32[] array = new Int32[100];
```

This code uses two reference types: the array type **Int32[]** and the element **Int32**. The **new** operator will need to:

- Create 100 objects of type **Int32** (I am calling them objects under the assumption that **Int32** is a reference type). Each object has a memory overhead to be self-describing.
- Create the array object and initialize the overhead associated with it.
- Initialize the array object so that each element refers to an **Int32** object.

The **Int32** type is a very simple type and an instance of this type is just 4-byte in size. But since we have assumed that **Int32** is a reference type, there will be some overhead associated with each instance. This is very awkward because the overhead is large compared to the size of the instance itself. While 100 **Int32** instances need only 400 bytes, much more memory will be allocated.

Types like **Int32** and **Double** are simple, small, and frequently used. To improve performance and to make more effective use of the available memory, the CTS offers value types. An instance of a value type has zero overhead because it&#39;s not self-describing. A variable of a value type directly contains the fields of the instance instead of a reference. For this reason, variables of value types contain the instance. On the other hand, a variable of a reference type holds a reference to the instance. Now since **Int32** is a value type, when the code below executes:

```
Int32[] array = new Int32[100];
```

There will be only one new object created, the array object. All **Int32** values are directly contained within the object. Consequently, less memory is consumed and the overall performance can be significantly improved.

### 1.1.2 The CTS Type Hierarchy

The C# programming language provides five keywords to declare types. Types declared via one of the keywords **class** , **interface** , and **delegate** are reference types. Types declared via one of the keywords **struct** and **enum** are value types. Different .NET programming languages provide different keywords for reference and value types.

The CLR differentiates between value types, object types, interface types and pointer types as follows. The **System.Object** type is the ultimate base type of all object types and itself is an object type and doesn&#39;t have a parent type. That is, a type is an object type if and only if it&#39;s **System.Object** or derives from it. For example, **System.IO.FileStream** is derived from **System.IO.Stream** , which in turn derived from **System.Object**. Consequently, **System.IO.FileStream** and **System.IO.Stream** are reference types.

All value types are not derived from any type and do not implement any interfaces. However, every value type has a corresponding object type called the boxed type. A boxed type is either derived from the reference type **System.ValueType** or the reference type **System. Enum** , which in turn is derived from **System.ValueType**. For example, **System.Int32** and **System.DateTime** are value types and their corresponding boxed types are derived from **System.ValueType**. People commonly say &quot; **System.Int32** is derived from **System.ValueType**.&quot; Although not accurate, but might be convenient.  I&#39;ll discuss later in this chapter what boxed types are and why they are needed.

Figure 1‑1: The hierarchy of types in the CTS. All boxed enumerations are directly derived from the reference type System.Enum. All other boxed value types are directly derived from System.ValueType. All other object types are ultimately derived from System.Object. Pointer types and interfaces belong to reference types, but inheritance is not defined for them. Inheritance and interface implementation are not defined on value types. Note that in C# terminology, pointer types are not considered to be reference types. Generic type parameters are types like interfaces; they only partially describe their instances. They are more like type placeholders which, at run-time, will be replaced by reference or value types. That&#39;s why they are not considered to be a third kind of types. Generics are discussed in Chapter 9.

Figure 1‑1 shows the inheritance hierarchy of all types in the CTS. This chapter will discuss the **System.Object** and **System.ValueType** reference types. All other type shown in the figure will be discussed in subsequent chapters. Note that there are types, including all value types, that don&#39;t inherit from any type and no type can inherit from them.

Inheritance and interface implementation is not defined for value types and pointers types. Instances of these types are not self-describing and therefore they cannot support polymorphism. Values types are designed to be lightweight and their instances should be small in size. Inheritance is also not defined for interfaces because interfaces cannot describe the representation of values. However, an interface can naturally implement other interfaces. Interfaces are discussed in detail in Chapter 2.

A type cannot immediately derive from more than one type. The CLI does not support _multiple inheritance_ (the CLR does not support it too). However, a type can implement zero or more interfaces. For example the base type of boxed **System.Int32** is **System.ValueType** and it also implements several interfaces, one of them is **System.IComparable**. Another example is **System.Object** which implements zero interfaces.

The following statement defines a reference type:

```
class Foo { /* Members */ }
```

The code shows that **Foo** does not derive from any type. However, when the C# compiler compiles this code, it will see that the type is declared with the **class** keyword, and hence it is a reference type. So the compiler will automatically specify **System.Object** to be the base type of **Foo**. Therefore, that code is equivalent to this code:

```
class Foo : Object { /* Members */ }
```

Both of these declarations are equivalent. Declaring value types is different. The following code declares a value type:

```
struct Foo { /* Members */ }
```

Similarly, the code shows that **Foo** does not derive from any type. However, the compiler will see that it is declared with the **struct** keyword and hence it knows that there is a corresponding boxed type that has the same fields and methods and is derived from **System.ValueType**. The difference is that you cannot explicitly make **Foo** to derive from **ValueType**. If you tried to compile the following code:

```
// Any base object type, even ValueType, cannot be specified.
struct Foo : ValueType { /* Members */ }
```

the compiler will emit the following error: **Type &#39;ValueType&#39; in interface list is not an interface**. The compiler is saying that the type specified is not an interface. In fact, the compiler clearly indicates that what comes after the colon is an interface list and so only interfaces can be included in this list. The C# compiler will always automatically make boxed struct types to be derived from **ValueType**.

You can use the **enum** keyword to declare enum types as the following code demonstrates:

```
enum Foo { /* Constants */ }
```

While all boxed enum types are derived from the **System.Enum** reference type, you cannot explicitly specify the base type. Moreover, the CLR and the C# compiler do not allow enum types to implement interfaces. An enum type is just a collection of named constants, nothing more and nothing less. The reason that enum types are value types is that they are very simple and an instance of an enum type is of size at most 8 bytes. **System.Enum** is one of the types that are specially treated by the CLR. Enum types are discussed in detail in Chapter 10.

### 1.1.3 Implementation Details Matter

So far, I've been a little formal when discussing reference and value types. However, the way these types are allocated and deallocated can significantly impact performance and therefore you should know about these implementation details. Whenever you want to design a type, you have to decide whether this type should be a reference type or a value type. In order to be able to make such decision, you should understand precisely the differences between reference and value types. In this section, I will present the fundamental differences between them and demonstrate their impact on performance and memory according to how they are typically implemented by CLI-conformant runtimes.

The CLR currently implements references as pointers. Consequently, the size of a reference type variable is the same as the size of an address on the target machine (typically, 32 or 64 bits). Copying a reference can be done in a single instruction on x86, x64, and ARM. Although references seem very much like ordinary pointers, there is an essential difference. While a pointer can be arithmetically manipulated, a reference can only be changed using the assignment operator. The advantage of this is that an essential feature called _type safety_ would only be possible with reference types. Section 1.4 provides an introduction to type safety, and I will say much more about it in subsequent chapters. Type safety is one of the most important advantages (if not the absolute most important) of writing code in a managed language.

Instances of object types are always allocated from the managed heap. While the runtime may maintain more than one managed heap, I&#39;ll collectively refer to all of these heaps as the managed heap as long as accuracy is not compromised. Instances of value types and pointer types can exist almost anywhere in memory.

I will use the code below to demonstrate the behavior of instances of reference types and value types at run-time. The code declares a reference type called **SomeRef** that has a single **public** field of type **Int32** and a value type called **SomeValue** that has also a single **public** field of type **Int32**. Note that you should never declare **public** fields in production code, but I declared them **public** to simplify the code and gear attention toward reference and value types.

```
using System;

// This is a reference type.
class SomeRef { public Int32 Integer;}

// This is a value type.
struct SomeVal { public Int32 Integer; }

class Program {
    static void Main() {
        SomeRef myRef = new SomeRef(); // Creating a SomeRef instance in heap.
        SomeVal myVal = new SomeVal(); // Creating a SomeVal instance on stack.

        Change(myRef); // Passing the identity of myRef.
        Change(myVal); // Passing a copy of myVal.

        Console.WriteLine(myRef.Integer); // 10
        Console.WriteLine(myVal.Integer); // 0

        // Arrays are reference types. These are allocated in the heap.
        SomeRef[] refArray = new SomeRef[3]; // All elements are null.
        SomeVal[] valArray = new SomeVal[3]; // All elements are initialized to 0.

        refArray[0] = new SomeRef(); // The first element is now referring to an object.
        refArray[1] = new SomeRef(); // The second element is now referring to an object.
        refArray[2] = new SomeRef(); // The third element is now referring to an object.

        Console.WriteLine(refArray[0].Integer); //  0
        Console.WriteLine(valArray[0].Integer); //  0

        myRef = null; // Reference type variables can be null.
        // myVal = null; // Value type variables cannot be null.

    }

    static void Change(SomeRef arg) {
        arg.Integer = 10; // Changing the same object.
        arg = new SomeRef(); // Changing the reference.
    }

    static void Change(SomeVal arg) {
        arg.Integer = 10; // Changes the copy.
    }
}
```

Figure 1‑2 (a) shows the variables and the managed heap objects at the time **Main** is called. Notice that the memory space of all variables has already been reserved and not yet initialized. There will be some other values on the stack and some objects in the heap created by the CLR, but are not related to this discussion and so I will omit them.

Figure 1‑2: (a) The state of the thread stack and the managed heap when Main is called by the CLR. (b) The state of the stack and the managed heap after initializing the myRef and myValue local variables. The question mark &quot;?&quot; indicates an unkwon value. The stack grows downward.

Since the **myRef** variable is of the **SomeRef** reference type, the **refArray** is of the **SomeRef[]** reference type, and the **valArray** is of the **SomeVal[]** reference type, all of these variables will contain references on the stack.  On the other hand, since the **myVal** variable is of the **SomeVal** value type, the variable will directly contain the instance. Consequently, the **Integer** field of the **myVal** instance will be allocated on the stack. If **SomeVal** defined more instance fields, all of them will also be allocated on the stack. So even if a method never uses a variable of a value type in a particular execution path of the code, the variable may still be allocated. In contrast, instances of reference types are only allocated from the managed heap when the **new** operator executes.

Figure 1‑2 (b) shows what happens on the thread stack and the managed heap when the first two lines of the **Main** method executes. The **new** operator when used with a reference type has a different purpose when used with a value type. When the **new** operator executes for the **SomeRef** reference type, the following steps are performed so that a new object is created and initialized in the managed heap:

1. Calculates the number of bytes required by a **SomeRef** instance, which is the size of all fields in **SomeRef** plus the size of all fields that are declared by its base type, up to the **System.Object** type (which does not derive from any type), in addition to the sync block index and the type object pointer, which are used by the CLR to support polymorphism and some other functionalities. The size of the **Int32** field is always 4 bytes, the size of each of the sync block index and the type object pointer is equal to the size of the memory address. The total size is 12 bytes on 32-bit machines and, 24 bytes on 64-bit machines (the extra 4 bytes are for alignment).
2. Allocates 12 bytes (or 24 bytes) from the managed heap to store the new **SomeRef** instance. These bytes exist in a memory segment that might have already been zeroed out. If not, these 12 bytes are zeroed out. Either way, the value of the **Integer** field is now 0.
3. Initializes the sync block index and the type object pointer. A type object pointer is part of the header of every object. It holds a reference to an object of type **System.RuntimeType** that exactly describes the type of the object. An instance of type **RuntimeType** is called a type object and will be discussed in detail later in this book. A type object contains the static fields of the type and pointers to the machine code of its instance, virtual, and static methods. If this is the first instance of **SomeRef** to be created, a type object representing **SomeRef** has to be created first and initialized. The sync block index is used by the runtime for miscellaneous purposes.
4. Calls the default constructor of the exact type of the object.

These steps are performed by a component of the runtime called the garbage collector (GC). The GC is responsible for on-demand allocation and automatic deallocation of objects from the managed heap. When a new object is going to be created, the garbage collector may need to perform a collection to make a space on the heap to allocate the object, thereby hurting performance. Therefore, creating too many objects will increase the number of collections resulting in a great negative impact on performance.

After the object has been created and initialized, the address of the type object pointer is stored in the **myRef** local variable. The behavior of the **new** operator for value types in general will be discussed in Chapter 2. But for the **SomeVal** value type, it simply initializes the location of **myVal**. So after it has been executed, the **Integer** field of the **myVal** variable is set to 0. Now that the **myRef** and **myVal** variables have been initialized, they can be used. Using uninitialized variables is not verifiable and is only allowed when the code is either fully trusted or has been granted a security permission with skip verification turned on. I&#39;ll provide an introduction to verification in Section 1.5.

The code then calls the **Change** method passing the value of the **myRef** local variable. Since the type of the variable is a reference type, it contains a reference, not an instance. This means when the value is copied to the **arg** parameter, a copy of the reference will be passed. Figure ‎1‑3 (a) demonstrates this. The figure shows that both the variable and the argument contain references to the same object on the managed heap. The **Change** method will use the **arg** reference to access the object and change the value of its **Integer** field to 10. Any modifications to the object performed by the **Change** method will be seen by the **Main** method because both refer to the same object. Then a new instance of **SomeRef** is allocated and its reference is stored in **arg**. This doesn&#39;t change the value of myRef because they are stored in different locations and so they would be referencing different objects. This new object is not shown in Figure ‎1‑3.

Next, the other overload of the **Change** method is called, which has a parameter of type **SomeVal**. Since **SomeVal** is a value type, its instances directly contains the values of its fields. Figure ‎1‑3 (b) demonstrates how the **myVal** variable is passed to the **arg** parameter. The **Change** method will get a copy of the **SomeVal** instance. Because of this, any modifications performed to this instance within **Change** , does not affect the instance hold by the **myVal** variable. Therefore, when the value of **arg**&#39;s **Integer** is changed to 10, **myVal**&#39;s **Integer** will still be 0. It&#39;s tempting to believe that the value type instance being altered is the same as the original instance because value type variables and reference type variables are copied using the same exact syntax in C#.

Figure 1‑3: (a) Shows the state of the thread stack and the managed heap when Change is called passing myRef, a reference to an object. (b) Shows the state of the thread stack and the managed heap when Change is called passing myValue, an instance of a value type.

The code then creates two array objects in the managed heap and initializes the **refArray** and **valArray** variables to point to these objects. Notice that all array types are derived from **System.Array** which is derived from **System.Object** , so they are reference types.  Figure ‎1‑4 (a) shows how these objects look on the managed heap. Each array object has fields in addition to the sync block index and the type object pointer. All of these fields together are called &quot;overhead&quot; in the figure.  Since the elements of the first array are of the **SomeRef** reference type, each element contains a reference rather than that instance itself. When the array is first created, all of these elements will contain **null** indicating that they refer to no objects. On the other hand, the elements of the second array are of the **SomeVal** value type.  So each element of the array directly contains that instance. Each instance has only one field of type **Int32** which is initialized to 0.

While the elements of the **valArray** have already been initialized, the elements of the **refArray** all contain null references. So we have to explicitly create new instances of type **SomeRef** in the managed heap using the new operator and store references to them in the elements of the **refArray** object. Figure ‎1‑4 (b) shows the managed heap after the elements of **refArray** has been created and initialized. Because of the sync block index and the type object pointer associated with each of the reference type instances, the total size of the **refArray** array is nearly double the size of the **valArray** array.

Figure 1‑4: (a) Shows the state of the thread stack and the managed heap after the array objects are created. (b) Shows the state of the thread stack and the managed heap after the elements of the array referenced by the refArray variable are created and initialized. All of these elements become references to new instances on the managed heap.

We can see that arrays with reference type elements suffers from the following issues:

- Each element of a reference type requires a new object to be created in the managed heap to be initialized. This means that fully creating an array with reference type elements requires more time and memory than creating an array with value type elements.
- Arrays with reference type elements will cause much more pressure on the garbage collector than arrays with value type elements since they consume much more memory.
- Arrays with reference type elements could exhibit much worse spatial locality of reference because the objects referred to by its elements may not be contiguous in the managed heap. This leads to inefficient utilization of the processor cache system.

Because of all of these problems, arrays with value type elements are preferred over arrays with reference type elements, especially when the value type has a small number of small fields.

Finally, the code shows that we can assign **null** to the **myRef** variable, but not to the **myVal** variable. The value **null** is a special value that indicates no object is referenced. So it makes sense to say that a reference type variable is **null** to indicate that it does not refer to an object, but it does not make sense to say that a value type variable is **null** because the variable directly contains the values of its fields. If you attempted to assign **null** to **myVal** , the C# compiler will emit the following error: **Cannot convert null to &#39;SomeVal&#39; because it is a non-nullable value type**. However, the CLR offers a feature called _nullable value types_ which are special value types that we can assign **null** to their instances. I will discuss them in chapter 5. Note that all reference types are nullable except for managed pointers which can never be **null**.

Instances of value types are automatically deallocated when the method returns because the stack of the method will unwind. Consequently, instances of value types have short life times. This explains why instances of value types incur zero pressure on the garbage collector (unless they have one or more fields of reference types or are part of an object). On the other hand, instances of reference types are automatically deallocated by the garbage collector at some convenient time. The garbage collector will only deallocate an object when it is not reachable from the AppDomain that created it. Therefore, instances of reference types can have very long life times and can live beyond the methods that have created them.

The code snippet below shows what happens if you accessed a reference type variable that contains **null**. The code first declares two variables of types **SomeVal** and **SomeRef**. As previously mentioned, a space on the stack will be reserved for these variables. However, while **myVal** directly contains the **Integer** field, **myRef** only contains a reference which is currently not specified. The code then assigns 10 to the **Integer** field of the **myVal** variable and assigns null to the **myRef** variable.

```
SomeVal myVal; // A variable of type SomeVal is allocated on the stack.
SomeRef myRef; // A variable of type SomeRef is allocated on the stack.

// The variables are initialzied.
myVal.Integer = 10;
myRef = null;

Console.WriteLine(myVal.Integer); // 10
Console.WriteLine(myRef.Integer); // NullReferenceException is thrown.
```

Finally, the code prints the **Integer** field of the **myVal** variable to the console which will execute with no errors. But when printing the **Integer** field of the **myrRef** variable, the CLR detects that the variable is **null** and so the **Integer** field does not exist. Therefore, the CLR will throw a **NullReferenceException**.

All boxed value types are derived from **System.ValueType** which is derived from **System.Object**. Both **ValueType** and **Object** are reference types. An instance of a value type can be converted to **ValueType** and **Object** via a special operation called _boxing_. For example, since **Int32** is a value type, you can convert an **Int32** instance to **ValueType**. But there is a small problem. The following code demonstrates it:

```
Int32 int32 = 10; // A value type instance
ValueType vt = int32; // Convert to ValueType. A new object is created.
Object obj = vt; // Convert to Object. The vt reference is copied to obj.
int32 = (Int32)obj; // Convert back to Int32.
```

As I&#39;ve previously discussed, the thread stack will contain three variables **int32** , **vt** , and **obj**. Since **Int32** is a value type, the **Int32** instance is allocated on the stack. However, since **ValueType** is a reference type, the **vt** variable will contain a reference, not an instance. So how do you convert from **Int32** to **ValueType**? In order to do this, you have to create an object on the managed heap that represents the **int32** instance and store a reference to this object in the **vt** variable. This process is called boxing and the resulting object is called a _boxed value type instance_. At this point, the **vt** variable holds a reference to a boxed instance. The reference is of type **ValueType** and the location in which it&#39;s stored is of type **ValueType** as well. Now since **Object** is also a reference type, you can directly assign the reference contained in **vt** to **obj**. Therefore, after executing this conversion, both the **vt** and **obj** variables will contain references to the same boxed **Int32** instance except that the location of **obj** is of type **Object**. This is an example where the type of the location is different from the type of the value stored in it. The runtime can determine the types of locations in the stack by examining the CIL code. These types will be omitted from the resulting machine code. Therefore, these types exist only at the virtual execution system level.

The last line of this code converts **obj** back to **Int32**. In order to do this, you have to _unbox_ the object by locating the **Int32** instance within the object, and then copy that instance to the **int32** variable. The important point here is that having too much boxing may significantly reduce performance and consume memory. Chapter 3 has all the details.

The following list summaries the differences in the implementation of value and reference types:

- Assigning reference type variables or passing them to parameters means copying the references. In contrast, assigning value type variables or passing them to parameters is potentially slower because it means copying the whole instances.
- Reference type variables can be **null** whereas value type variables always contain an instance.
- Declaration of a reference type variable does not cause an instance to be created whereas declaration of a value type variable does cause an instance to be created even if the variable is never used (unless the CIL translator was able to optimize it away). New reference type instances can only be created by executing the **new** operator.
- Allocations and deallocations of reference type instances are relatively slow, increase the pressure on the garbage collector, and consume more memory. In contrast, allocations and deallocations of value type instances are performed almost instantly by incrementing or decrementing the stack pointer. For this reason, value types are called lightweight types. Typically, most of the memory managed time is spent in deallocating objects.
- A non-null reference identifies a unique object in the managed heap. A value type instance can be identified only by obtaining a managed or unmanaged pointer to the instance.
- Arrays of value type elements exhibit better spatial locality of reference because all elements are always contiguous in memory. In contrast, arrays of reference type elements could exhibit bad spatial locality of reference. In addition, initializing these arrays requires **new** ing up all elements. An array of a value type element, once created, all of its elements have already been created and initialized to all-bits-zero.
- Converting a value type instance to a compatible reference type requires a reference to an object to be generated. This is achieved by boxing the instance into an object in the managed heap, increasing the pressure on the garbage collector, consuming more memory, and degrading the overall performance. This could be a problem when too much boxing and unboxing occur.
- Types cannot be derived from value types. For example, you cannot have a type that is derived from **System.Int32**. Consequently, value types cannot be used as base types and cannot be marked **abstract**. Also this means that you should not introduce virtual methods in value types because they will never be overridden. While the CLR allows value types to offer new virtual methods, the C# compiler will emit an error. In addition, the C# compiler implicitly marks all value types as sealed.
- Local value type variables may have definite lifetimes as determined by the scope they are defined in. On the other hand, an object will remain in memory as long as there is at least one reference to it in the AppDomian that created it.
- Initialization of value type instances can be done without calling any instance constructor as I will briefly explain next. In contrast, Initialization of reference type instances can only be done by calling an instance constructor.

In Chapter 4, I will explain why each reference type must have at least one instance constructor whereas value types may or may not have any instance constructors. I will also explain in Chapter 4 why an instance constructor must be called in order to create a new instance of a reference type. On the other hand, value type instances will be automatically created on the stack whether a constructor is called or not. Since value type instances are already there on the stack, and since they don&#39;t need to have instance constructors, the CLR and C# allow us to initialize them and access their fields without calling any constructor. So you can initialize value type instances without calling any constructors. The following code demonstrates this:

```
SomeRef myRef; // An instance is not created.
SomeVal myVal; // An instance is created.

// Let's initialize the variables.
myRef = null; // No instance is created.
myRef = default(SomeRef); // Assigning null again. No instance is created.
myVal = default(SomeVal); // All fields are zeroed out and no constructor is called.

// Let's initialize the variables in another way.
myRef = new SomeRef(); // All fields are zeroed out and a constructor is called.
myVal = new SomeVal(); // All fields are zeroed out again, and no constructor is called.
```

The code shows that declaring a reference type variable causes a memory region for the reference to be allocated on the stack (or in a processor register) whereas declaring a value type variable causes a memory region to be allocated for the whole instance on the stack. Now in order to write verifiable code, you have to initialize these variables before using them. The code has initialized **myRef** to **null** and **myVal** to its default value. The **default** operator returns **null** for all reference types and sets all bits zero for value types. At this point, you can read and write to any of the fields of **myVal**. In contrast, **myRef** does not even refer to an object. To do this, you have to use the new operator to allocate an object in the heap, initialize its fields to all bits zero, and call an instance constructor which could change the values of the fields. Executing the **new** operator for a value type allows us to either call an instance constructor or a specialparameterless constructor as shown in the code. What&#39;s really happing is that no constructor is being called; this has the same effect as the **default** operator. In fact, the same exact code will be emitted. Refer to chapter 4 for more information about instance constructors.

### 1.1.4 The System.Object Type

As shown in Figure 1‑1, **Object** is the ultimate base type of all object types except for **Object** which itself doesn&#39;t have a base type. Therefore, an instance of any object type is also an instance of **Object**. It&#39;s important to be familiar with all the methods and fields defined in **Object**. Many of them are useful and you&#39;ll be using them quite often. The following code shows an abbreviated definition of the **Object** type.

```
public class Object {
    // Allows us to create Object instances.
    public Object() {
        // Does nothing.
    }

    // Compares two objects for equality.
    public virtual Boolean Equals(Object obj) {
        // The implementation is logically equivalent to the static Equals.
    }

    // Compares two objects for equality.
    public static Boolean Equals(Object objA, Object objB)
    {
        return ((objA == objB) ||
            (((objA != null) &amp;&amp; (objB != null))
            && objA.Equals(objB)));
    }

    // Returns a hash code for the current instance.
    public virtual Int32 GetHashCode() {
        // Returns a value that is statistically unique within the appdomain.
    }

    // Compares two objects for identity.
    public static Boolean ReferenceEquals(Object objA, Object objB) {
        return (objA == objB);
    }

    // Returns a string representation of the instance.
    public virtual String ToString() {
        return this.GetType().ToString();
    }

    // Notifies the object when it is about to be deallocated.
    protected virtual void Finalize() {
        // Does nothing.
    }

    // Returns a shallow copy of the instance.
    protected extern Object MemberwiseClone();
    
    // Returns a reference to the type object of the exact type of the instance.
    public extern Type GetType();

    // Other private members that are not important at this point but will be discussed later
    // in this book.
}
```

Notice that the type defines no fields whatsoever. Therefore, it doesn&#39;t add anything to the representation of objects. Unless a derived type defines at least one field, instances of that type will have no state besides the sync block index. However, it does define a number of instance and static methods and so provides a (partial) description of the behavior of objects. Now I&#39;ll explain each method:

1. The parameterless constructor contains no code. This is called when instances of Object or other object types are created. Refer to chapter 4 for more information on constructors.
2. The virtual method **Equals** , for reference types, compares the references, not the values of the objects. This method is overridden in the **System.ValueType** to perform value equality for value types. If you defined a value type, it is recommended that you override this method because its default implementation is slow since it uses reflection to discover the fields of the type. In general, you should override this method to check for equality.
3. A static **Equals** method, this method handles **null** values in contrast to the virtual **Equals** method. If both parameters are not **null** , this method calls the virtual **Equals**. For more information on comparing variables for equality, refer to chapter 4.
4. The **GetHashCode** returns an integer that is statistically unique in the application domain where this object is created. This method is called when the object is used as a key in a dictionary object. For more information, refer to chapter 4.
5. The static **ReferenceEquals** method always compares references. Notice that the parameters of this method are reference types which makes sense. Value types do not have references.
6. The virtual **ToString** method returns the fully qualified name of the object&#39;s exact type. You should override this method to return a useful string representation of the object instead of the fully qualified name of its type. In chapter 9, I&#39;ll discuss to efficiently work with strings.
7. The **Finalize** method contains no code. It&#39;s a special method that is defined by **Object** so that all object types have the ability to tell the garbage collector what it&#39;s required to do when it&#39;s about to deallocate objects. Later in this book, I&#39;ll discuss garbage collection in detail.
8. The protected **MemberwiseClone** method creates a new instance of the type and copies the object&#39;s fields to the new instance. A reference to the new instance is returned. This copy operation is shallow, meaning that if one of the object&#39;s fields is a reference type, the reference is copied, not the object to which this reference is pointing.  For more information on cloning and copying, refer to chapter 2.
9. The **GetType** method returns an instance of a **System.Type** -derived type. This instance contains information about the object&#39;s exact type. You can use this object to get various information about the type.

All of these methods make sense to be defined in **Object**. You may not feel this way towards the **GetHashCode** method. One might argue that most types are not used as keys in dictionaries. However, looking at it from a different perspective, with this method, you can use hashing whenever you need to without worrying about whether the object supports hashing or not.

You might notice that the C# compiler, apparently, allows to call these methods using a value type instance such as **Int32**. However, I said earlier in this chapter that value types don&#39;t derive from any type including **Object**. In addition, **Int32** doesn&#39;t define these methods. So how is it possible that you can call these methods on an **Int32** value? It&#39;s actually just a syntactic sugar provided by C#. What&#39;s really happening internally (by looking at the CIL code) is that the value is getting boxed so that an instance of boxed **Int32** is created and the method is called on that instance. I&#39;ll discuss boxed types later in this chapter.

## 1.2 CTS Built-In Types and CIL Supported Types

Every programming language defines a number of types that can be used to build other types. These types are called _built-in types_. Types that consist of one or more fields of built-in types or other types are called _compound types_. Some people use the term primitive types or intrinsic types to refer to (some) built-in types. However, I find these terms confusing because they mean slightly different things to different people or in different contexts and therefore I&#39;ll refrain from using them.

Table 1 shows the built-in types of the CTS. High-level languages targeting the CLI such as C# can have their own set of built-in types that may not be exactly the same as CTS&#39;s. For example, **System.Boolean** is a built-in type in both the CTS (in which it&#39;s called **bool** ) and C# (in which it&#39;s also called **bool** ). In contrast, **dynamic** is a C# built-in type and not a CTS built-in type. **System.IntPtr** is a CTS built-in type (called in **native int** ) and not a C# built-in type. Note that since C# programs will be compiled to CIL, all C# built-in types have to be represented using CTS built-in types or other types that CIL can understand. For example, all **dynamic** variables will be of type **System.Object** in CIL. The C# compiler is responsible for maintaining the semantics of these variables by emitting the necessary CIL code and metadata.

Table 1: CTS built-in types.

| Name in CIL assembler | CLS type | Name in class library | C# built-in type name | Description |
| --- | --- | --- | --- | --- |
| bool | Yes | **System.Boolean** | **Bool** | True/false 8-bit value. **False** is represented as all-bits-zero. **True** is represented as at-least-one-bit-set.<sup>3</sup> |
| char | Yes | **System.Char** | **Char** | Unicode 16-bit char |
| object | Yes | **System.Object** | **Object** | Base type of other object types |
| string | Yes | **System.String** | **String** | An array of values of **char** |
| float32 | Yes | **System.Single** | **Float** | IEC 60559:1989 32-bit floating-point value |
| float64 | Yes | **System.Double** | **Double** | IEC 60559:1989 64-bit floating-point value |
| int8 | No | **System.SByte** | **Sbyte** | 8-bit two&#39;s-complement signed value |
| int16 | Yes | **System.Int16** | **Short** | 16-bit two&#39;s-complement signed value |
| int32 | Yes | **System.Int32** | **Int** | 32-bit two&#39;s-complement signed value |
| int64 | Yes | **System.Int64** | **Long** | 64-bit two&#39;s-complement signed value |
| native int | Yes | **System.IntPtr** | N/A | Signed integer, native size |
| native unsigned int | No | **System.UIntPtr** | N/A | Unsigned integer, native size |
| typedref | No | **System.TypedReference** | N/A | Pointer plus exact type |
| unsigned int8 | Yes | **System.Byte** | **Byte** | 8-bit unsigned binary value |
| unsigned int16 | No | **System.UInt16** | **Ushort** | 16-bit unsigned binary value |
| unsigned int32 | No | **System.UInt32** | **Uint** | 32-bit unsigned binary value |
| unsigned int64 | No | **System.UInt64** | **ulong** | 64-bit unsigned binary value |

All of the CTS built-in types have special names and encoding in CIL. At the same time, you may have noticed that many of them have traditional type definitions in the **mscorlib.dll** class library. Why do we need the class library definitions and what&#39;s the difference between the two? They are needed so that we can define utility methods that can be conveniently used by developers who are using high-level languages or CIL. Regarding the difference between them, at a high-level language level, only the class library names are available (in addition to keywords that provide alternative names or aliases to them). However, if you&#39;re implementing a compiler or writing code directly in CIL, then you have two names to choose from: the CIL name and the class library name. The CLI states in II.7.2 that built-in types shall be referenced in signatures only using their special encodings; not using the class library name. Consequently, I believe that the CLR should generate an exception of type **InvalidProgramException** when specifying signatures that use the class library names of built-in types. The CLR doesn&#39;t follow this rule and allows both names to be used. But, unfortunately, this doesn&#39;t always work as expected as I&#39;ll show later in this chapter.

When designing an API for a class library implemented in C#, it&#39;s recommended that you use the class library names rather than the C# alias names. For example, use **GetInt64Length** rather than **GetLongLength**. This makes it easier for the class library to be used from other languages.

The alias names of the C# built-in types and their class library names follow an interesting naming convention. To see this, note that **Int32** represents 32-bit signed integers and **Uint32** represents 32-bit unsigned integers. But **Byte** represents 8-bit unsigned integers and **Sbyte** represents 8-bit signed integers. Why **Byte** is not named like **Int32**? That is, why does it not represent 8-bit signed integers? The reason for this is to make it easier to remember which types are non-CLS-compliant. For 32-bit integers, those that are unsigned are non-CLS-compliant, but for 8-bit integers, those that are signed are non-CLS-compliant. With these names, you can easily remember which built-in types are not CLS-compliant; those types that their names are prefixed with an extra letter, either U (for unsigned) or S (for signed).

The CIL is an assembly language that can be executed by the execution engine. Just like any assembly language, it has a set of _supported types_ that can be used as types for instruction operands or results. If you want to implement a tool that generates or analyzes CIL code, it&#39;s important that you understand them. These types are shown in Table 2. Note that the CTS types **bool** and **char** are treated in CIL as **unsigned int8** and **unsigned int16** , respectively. This simplifies the CIL. Also note that for pointer types, CIL separates between the type of the pointer and the type of the location being pointed to. CIL treats instances of type **O** as opaque values. Their exact meaning is implementation-dependent. The CLR implements object references as pointers. Unmanaged pointers are treated just like unsigned integers. Managed pointers have a different type than unmanaged pointers because they are constrained. I&#39;ll discuss these types later in this chapter. The floating-point type **F** is the type whose instances can be operated on by CIL instructions. I&#39;ll discuss this type later in this book.

Table 2: CIL supported types.

| CIL type | Description | Corresponding CTS types |
| --- | --- | --- |
| int8 | 8-bit two&#39;s-complement signed value | **int8** |
| unsigned int8 | 8-bit unsigned binary value | **unsigned int8** , **bool** |
| int16 | 16-bit two&#39;s-complement signed value | **int16** |
| unsigned int16 | 16-bit unsigned binary value | **unsigned int16** , **char** |
| int32 | 32-bit two&#39;s-complement signed value | **int32** |
| unsigned int32 | 32-bit unsigned binary value | **unsigned int32** |
| int64 | 64-bit two&#39;s-complement signed value | **int64** |
| unsigned int64 | 64-bit unsigned binary value | **unsigned int64** |
| float32 | IEC 60559:1989 32-bit floating-point value | **float32** |
| float64 | IEC 60559:1989 64-bit floating-point value | **float64** |
| native int | Native size two&#39;s-complement signed value | **native int** |
| native unsigned int | Native size unsigned binary value, also unmanaged pointer | **native unsigned int** , **T\*** for any valid type **T** |
| F | Native size floating-point number | **float32** , **float64** |
| O | Native size object reference to managed memory | N/A |
| &amp; | Native size managed pointer (can point into managed memory) | **T&amp;** for any valid type **T** |
| null | Represents a single value, the **null** value, and defines no operations. | N/A |

The **null** value is defined to be all-bits-zero and its size to be the same as the size of a pointer, which is implementation-dependent. The **null** value is the identity of no object. That is, it doesn&#39;t identify any object. The **null** value is also called the **null** instance. All other values are referred to as non- **null** instances. But an instance of what? What is the type of **null**?

CIL defines the type of the **null** value to be the **null** type and it can be used as a type for locations in the evaluation stack (created using **ldnull** CIL instruction). The only other use of the **null** type is in the standard to define rules involving the **null** value (the CIL verifier makes use of this type to verify CIL code when enabled). The **null** type is not defined in the CTS or any class library. The **null** value can be assigned to locations of type **O** or **native unsigned int** and a CIL instruction that accepts an operand of type **O** or **native unsigned int** can also load the **null** value. This is done by implicitly converting between **null** and the corresponding **O** or **native unsigned int** instances, which are also all-bits-zero.

One of the IL verification rules mentioned in III.1.8.1.2.3 of the CLI says that if **T** is the **null** type and **U** is the **O** type then assigning an instance of **T** to **U** is verifiable. That is, the assignment can pass verification. The CLI says in II.13 that unboxed value types shall not be assigned the value **null** and they shall not be compared to **null**. This includes nullable value types. JIT compiling a method that performs such assignment results in undefined behavior. When assigning **null** to a location of CTS built-in value type, the CLR will accept the assignment when verification is not enabled and will throw a **System.VerificationException** when verification is enabled. Also when assigning **null** to a location of any other value type, the CLR will throw a **System.ExecutionEngineException** irrespective of verification.

The C# **null** literal can be used either as the **null** object reference or as the **null** unmanaged pointer. Attempting to dereference a **null** reference or a **null** pointer usually results in a **NullReferenceException**.

## 1.3 Feature Types

I will define a set of types called _feature types_. All of these types can be understood as features provided by the execution engine itself. When I make statements about types in this book, a statement may not be applicable to some of the feature types. However, for the convenience of writing this book, I&#39;ll not explicitly state which of the feature types apply or not. Therefore, when it matters to you, you&#39;re advised to amend such statements to explicitly consider the feature types.

### 1.3.1 System.Void and void

**System.Void** is a type that represents no-type. It&#39;s defined as follows:

```
public struct Void { }
```

This type cannot be used in C# in any way. Instead, C# offers the **void** keyword which can be used in only three ways. First, it can be used as the return type of a method. Second, it can be used to describe the pointer type **void\***. Third, it can be used as a parameter to the **typeof** operator. At the CIL level, **System.Void** can be used in only one way: as a parameter for the **ldtoken** instruction. Otherwise, a **System.InvalidProgramException** is thrown. Also at the CIL level, **System.Void** and **void** can be used interchangeably in the three ways mentioned above. Of course, this type does neither describe representation nor behavior of values. No location or value can have type **System.Void** and it&#39;s not boxable (there is no boxed **void** ). When people (including me) talk about value types or types in general, **System.Void** is considered to be excluded unless otherwise specified.

I would like to point out an important difference between using the library names of CTS built-in types (such as **System.Int32** ) and their corresponding native names (such as **int32** ). Consider the following method defined in metadata (the following experiment cannot be performed using C# so I&#39;m using **ilasm.exe** ):

```
.method public hidebysig static valuetype [mscorlib]System.Void  Foo() cil managed
```

Note that the return type is **System.Void**. Since it&#39;s the same as **void** , it&#39;s reasonable to expect that both of the following CIL instructions can be used to call the method:

```
call       valuetype [mscorlib]System.Void  Foo()
call       void Foo()
```

You might be surprised to know that only the first instruction can be used to successfully call the method while the second one will fail, resulting in an exception of type **System.MissingMethodException**. Note that inside a method that has a return type of **System.Int32** , you could define a variable of type **int32** and return its value even if the return type is **System.Int32**. This will work as expected. The reason that binding to the method fails is that the encoding of the method&#39;s signature in the metadata is different and the CLR is not able to bind the method call.

**Void** cannot be used as a type argument in instantiations of generic types and methods because it would be invalid in all useful generic types and methods. Also in C#, all type arguments must be either interface types, class types or boxable value types. Boxable types are defined later in this chapter.

### 1.3.2 System.Object, System.ValueType, System.Enum, System.Array, and System.Delegate

**System.Object** constitutes the ultimate base object type. As you saw earlier in this chapter, it provides a number of utility methods that all derived types inherit. It&#39;s an object type that doesn&#39;t have any state and it only describes the behavior of its instances. It allows us to create arrays or collections of items of different exact types. It also enables high-level languages to support dynamic typing as I will explain later in this book.

**System.ValueType** is an **abstract** reference type immediately derived from **System.Object**. **System.Enum** is an **abstract** reference type immediately derived from **ValueType**. All and only boxed value types are directly derived from **ValueType** or directly derived from **Enum**.

**ValueType** overrides **Equals** and **GetHashCode** to provide an implementation more suitable for value types. I&#39;ll discuss them in more detail in chapter 4. **Enum** overrides a number of methods and offers many new methods as well. There are many restrictions on types derived from **Enum** as discussed in detail in chapter 2. As you&#39;ll see in that chapter, the restrictions imposed on enumerations in C# are slightly more restrictive.

Note that in contrast to **ValueType** and **Enum** , **Object** is not **abstract**. This enables you to create instances of this type. This is convenient when all that you need is the sync block index.

If you are writing code in CIL, you can do weird things. For example, you can assign a reference to a value type variable without unboxing or a value type instance to a reference type location without boxing. You can do that even if the types are not related at all. Fortunately, the verifier, if enabled, will throw a **VerificationException** in such cases. Otherwise, the CLR allows the code to execute.

**System.Array** is the direct base type of all array types. Arrays are discussed in chapter 8. **System.Delegate** is the direct or indirect base type of all delegate types. The CLR considers **System.MulticastDelegate** to be the direct base type of all delegate types. **System.MulticastDelegate** is directly derived from **Delegate**. Delegate types are discussed in chapter 10.

### 1.3.3 Managed Pointer Types

Naturally, when an object is created, a reference to that object is returned. Object references are completely opaque values. They cannot be arithmetically manipulated. They can only be compared for equality or inequality. An object reference cannot be converted to something else; once an object reference, always an object reference. Since a reference identifies an object (except for **null** ), the only way to create a new reference is to create a new object.  That is, an object reference can only refer to an object as a whole. Everything I&#39;ve introduced so far doesn&#39;t enable you to obtain a reference to a particular field of an object. You might want to pass a reference to a part of an object to a method so that the method can modify it.

Managed pointers enables you to obtain a pointer to a field of an object, an element of an array, or an element just past the end of an array. In addition, you can use managed pointers to obtain pointers to local (potentially static) variables, parameters, static fields, and locations in unmanaged memory. Managed pointers cannot point to whole objects like references. A managed pointer is also called a _byref_ because they are used to implement pass-by-reference parameters. References and managed pointers have completely distinct usages and they are not interchangeable. The garbage collector must always be aware of all managed pointers to function correctly. The garbage collector might modify managed pointers if the objects into which they point are stored in the memory area that is under the control of the collector and those objects have been moved due to a collection. That&#39;s what makes managed pointers &quot;managed&quot; compared to unmanaged pointers. If managed pointers have been used in unpermitted ways, the behavior is undefined and therefore the code is not verifiable. A managed pointer that points to unmanaged memory is ignored by the GC and can be converted to an unmanaged pointer, but the conversion would not verifiable.

Note that a managed pointer is not an object reference, it&#39;s an actual address of a location. Managed pointers cannot be **null** because they are always supposed to point to a valid location and doing so results in undefined behavior. The CLR allows assigning **null** to managed pointers when verification isn&#39;t enabled and throws a **VerificationException** exception when it&#39;s enabled. The reason for this restriction is convenience. High-level languages are expected to not provide special syntax to dereference managed pointers, but rather to dereference them automatically whenever they are used. This elegant design would not have been possible without this restriction.

Managed pointer types are only allowed for non-static local variables, parameters, and return types; they may not be used for instance fields, static fields, static variables, or array elements. Also managed pointer types are not boxable; they don&#39;t have corresponding boxed types. Managed pointers don&#39;t have type objects or class library types that describe them. The reason for these restrictions is that in order to be able to perform garbage collection efficiently, no objects should have pointers to the interior of objects in the managed heap. I&#39;ll discuss this issue later in this book. Even if this was allowed, it would not be verifiable because managed pointers stored in fields of object have different lifetimes from stack and managed heap locations. In addition, the CLI specifies in I.8.9.7 that verifiable code can instantiate value types without calling constructors by automatically initializing them to zero. If it was allowed to have managed pointer fields in value types, it must be also allowed to have **null** managed pointers. Note that using managed pointers types as return types of methods is not verifiable.

There are a number of CIL instructions that can create what&#39;s known as _controlled-mutability managed pointers_. These pointers cannot be used to mutate the values they are pointing to using CIL instructions. The only way to change a value through such a pointer is when the type of the location in which its stored offers methods that can mutate it. This explains their name. The purpose of these pointers is to support read-only managed pointers.

A managed pointer can be arithmetically manipulated in three ways: adding an integer interpreted as a number of bytes, subtracting an integer interpreted as a number of bytes, or subtracting it from another pointer. In the first two cases, the result is a pointer of the same type. In the third case, the result is a signed integer. These operations are intended to be only used to iterate over arrays. Managed code that uses any of these operations is unverifiable. That&#39;s because the result might point into an arbitrary location in managed memory. In that case, the behavior is undefined. Manipulating managed pointers in any other way results also in undefined behavior. The rationale behind this is that the garbage collector may update managed pointers asynchronously, which can make concurrent pointer manipulations invalid. Overall, managed pointers are powerful enough so that you almost never have to use unmanaged pointers (which are not CLS-compliant and mostly result in unverifiable, buggy code).

Managed pointers are CLS-compliant and can produce verifiably type-safe code. Just make sure that managed pointers are used as specified previously. The verifier, if enabled, ensures that the lifetime of a managed pointer is contained within the lifetime of the location it points to.

Managed pointers are supported in C# through the **out** and **ref** keywords. In C#, managed pointers can only be used for parameters and cannot be arithmetically manipulated in any way. I&#39;ll discuss **out** and **ref** parameters in chapter 4. The proper use of managed pointers is guaranteed in C#.

Managed pointer types are named in CTS as **T&amp;** where **T** is any type except for a managed pointer type or **System.TypedReference** (which also represents a pointer)<sup>4</sup>. **T** is called the _referent type_. If **T** is a reference type, **T&amp;** represents a managed reference to an object reference, not an object. The CIL assembler thinks that the referent type **T&amp;** of **T&amp;&amp;** and the type **TypedReference&amp;** are regular types that are supposed to be explicitly defined and that&#39;s how they&#39;ll be encoded. Therefore, if you attempted to use such types, the CLR will try to look for type definitions with these names and will probably not find them, causing an exception of type **System.TypeLoadException** to be thrown.

Note that although managed and unmanaged pointer types are reference types, they are not object types. That&#39;s because instances of these types are not self-describing.

Managed pointer types cannot be used as type arguments in instantiations of generic types and methods. Attempting to do this causes a **TypeLoadException** exception during CIL translation. The rationale behind this restriction is that since these types cannot be used for fields and are not verifiable as return types, many of these instantiations will be invalid or unverifiable. In addition, there seems not be a good usage scenario for this feature.

### 1.3.4 System.TypedReference

This is a value type. An instance of **TypedReference** is a typed reference consisting of a managed pointer and the type of the location being pointing to. Typed references have all the restrictions of managed pointers.

That is, it shall only be used for parameters and local variables. It shall not be boxed, nor shall it be used as the type of a field or an element of an array. Typed references are as verifiable as managed pointers and are not CLS-compliant. A typed reference is a CTS built-in type designated by the keyword **typedref**.

In addition to the restrictions of managed pointers, the CLI disallows methods with return types of **TypedReference**<sup>5</sup>. However, the CLR allows such methods and considers them unverifiable. C#, on the other hand, doesn&#39;t allow such methods. However, methods defined in** TypedReference **and** ArgIterator** are exceptions to these two rules, meaning that they are recognized and allowed by the CLR verifier and the Visual C# compiler. I&#39;ll discuss why later in this section.

Typed references provide an alternative technique to boxing. To box a value, an object has to be created on the managed heap and the value has to be copied to that location. Typed references enable you to have a pointer to a value and to be able to determine the value&#39;s type dynamically without having to box the value. In other words, typed references enable high-level languages to offer dynamic dispatch based on value types. Also, typed references can be used together with **RuntimeArgumentHandle** and **ArgIterator** to implement methods with a variable number of arguments, called **vararg** _methods_or _variadic methods_. Standard C# supports only a restricted kind of variadic methods through the **params** keyword that don&#39;t use typed references as explained in chapter 4. However, Visual C# supports fully-fledged variadic methods as I&#39;ll show in the next section.

**TypedReference** is defined as follows (excluding custom attributes and some members):

```
public struct TypedReference {
    private IntPtr Value;
    private IntPtr Type;

    public override Int32 GetHashCode();
    public override Boolean Equals(Object o);
    public static Type GetTargetType(TypedReference value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    public unsafe static void SetTypedReference(TypedReference target, Object value);
    public unsafe staticObject ToObject(TypedReference value);
    public static TypedReference MakeTypedReference(Object target, FieldInfo[] flds);
}
```

The **Value** field is a pointer to the location in which the value being referenced is stored. The **Type** field is a pointer to the type object that represents the type of the location being referenced. Note that there are no constructors. There is only one way a new valid typed reference can be created, which is using the **mkrefany** CIL instruction. In Visual C#, however, you can create typed references in two ways: using the **MakeTypedReference** static method and using the **\_\_makeref** operator. The static method is advanced and will be discussed later in this book together with reflection. I&#39;ll show how to use the **\_\_makeref** operator shortly.

The **GetHashCode** method returns zero if **Type** is zero and calls **GetHashCode** on the type object referred to by **Type** otherwise. The **Equals** method simply throws a **System.NotSupportedException** exception. Recall that **TypedReference** is not boxable and since the parameter of Equals is of type **Object** , there is no way to pass a typed reference to the method. Note that although **GetHashCode** and **Equals** appears to be overriding the corresponding methods from **ValueType** , this is not the case. Virtual methods defined in any value type are always treated as non-virtual. Also calling virtual methods defined in **ValueType** , **Object** or an interface type requires boxing and so is only possible when the value type is boxable.

The **GetTargetType** method returns the value of the **Type** field if it&#39;s a valid reference to a type object. Otherwise, if the **Type** field is zero, the method returns **null**. Finally, if **Type** contains an invalid reference, the behavior is undefined and an **ExecutionEngineException** exception is thrown in the best-case scenario. This method is equivalent to the **\_\_reftype** Visual C# operator and, in fact, this is how it&#39;s implemented. Therefore, using the operator directly may be more efficient. I&#39;ll show how to use the **\_\_reftype** operator shortly. This operator is implemented using the **refanytype** CIL instruction. The **TargetTypeToken** method returns the type token of the type identified by the Type field. It simply returns the value of the expression **\_\_reftype(value).**[**TypeHandle**](http://referencesource.microsoft.com/mscorlib/system/type.cs.html#3b996698ffcafb07).

The **SetTypedReference** method was initially designed to change the value of the location being pointed to. The new value is passed to a parameter of type **Object** and so the implementation of this method make sure that the type is assignment-compatible with the type of the target location. This method was used internally to implement serialization in pre-.NET 2.0. Starting with .NET 2.0, the method is no longer needed and just throws an exception of type **NotSupportedException**.

The last method is **ToObject** which returns a reference of type **Object** to the value that is referenced by the given typed reference.  If the **Type** field is valid and represents a reference type, the value in the location pointed to by the **Value** field is returned. If the **Type** field is valid and represents a boxable value type, the value in the location pointed to by the **Value** field is boxed and a reference to the new object is returned. If the **Type** field is valid but represents an unboxable value type or if the type is invalid, an **ExecutionEngineException** exception is thrown in the best-case scenario. Finally, if the **Type** field is zero, an exception of type **System.ArgumentNullException** is thrown.

You might be wondering how to get the value that a typed reference is pointing to.  While **TypedReference** provide methods that enable us to get the type of the value, it doesn&#39;t provide any methods to get the value to which the **Value** field is pointing to. In fact, as you&#39;ll see shortly, it&#39;s impossible to provide such method. However, fear not, for the **\_\_refvalue** Visual C# operator will do exactly that. This operator is implemented using the **refanyvalue** CIL instruction.

Note that the **\_\_makeref** , **\_\_reftype** and **\_\_refvalue** operators are not part of standard C#. They are provided in Visual C# to be able to implement some types in C#. An example of a type that uses these operators is **TypedReference**. All of these operators are Visual C# keywords and they are not documented in the Visual C# documentation because they are rarely useful for C# developers.

Now I&#39;ll show an example that demonstrates how to use typed references in Visual C# using the aforementioned operators and how typed references are different from managed pointers and object references.

```
static void Main() {
    Int32 argument = 0;
    Foo(argument, argument, ref argument, __makeref(argument));
}

static void Foo(Int32 byvalue, Object boxed, ref Int32 byref, TypedReference typedbyref) {
    Int32 temp;
    temp = byvalue; // Reading from a by-value parameter.
    byvalue = 1; // Writing to a by-value parameter.

    if (boxed isInt32) {
        temp = (Int32)boxed; // Reading through an object reference.
        // Cannot write through an object reference.
    }

    temp = byref; // Reading from a by-reference parameter.
    byref = temp; // Writing to a by-reference parameter.

    if (__reftype(typedbyref) == typeof(Int32)) {
        temp = __refvalue(typedbyref, Int32); // Reading from a typed reference parameter.
        __refvalue(typedbyref, Int32) = temp; // Writing to a typed reference parameter.
    }
}
```

The **Main** method defines a local variable of type **Int32** and calls the **Foo** method passing to it the local variable in four different ways. The **Foo** method has four parameters. The first parameter is of type **Int32** , the second is of type **Object** , the third is of type **Int32&amp;** , and the fourth is of type **TypedReference**. Therefore, the first argument is passed by copying it, the second argument is passed by boxing it first and then copying the reference, the third argument s passed by copying a pointer to the location of the variable, and the fourth argument is passed by copying the typed reference. The \_ **\_makeref** operator has been used to create the typed reference. The **Foo** method uses all of the three ways to pass arguments as specified in the CLI: by-value (the **byvalue** and **boxed** parameters), by-reference (the **byref** parameter)<sup>6</sup> and typed reference (the **typedbyref** parameter).

Inside **Foo** , I show how to read from and write to each parameter. Accessing the first parameter is straightforward. Before accessing the second parameter, I used the **is** C# operator to make sure that the boxed value is of the expected type. The second parameter has to be unboxed first to get the value. Unboxing creates a value in a different location. There is no way to write to the boxed value. C# enables you to access values through managed references using the same straightforward syntax. Before accessing the fourth parameter, I used the **\_\_reftype** operator to make sure that the value being pointed to is of the expected type. The **\_\_refvalue** operator I used to read from or write to the typed reference.

Note that for managed pointers, the type has to be specified statically to define them as is the case with the **byref** parameter. You don&#39;t have to specify the type again when using the managed pointer. On the other hand, the type in typed references is stored in a field and can dynamically change by simply assigning to it. Therefore, the type is not specified statically. However, in order to access or modify the value stored in the referenced location, a type must be specified. That&#39;s the purpose of the second parameter of the **\_\_refvalue** operator. You can also use generic parameters as shown in the following code:

```
static T DereferenceTypedByref<T>(TypedReference typedbyref) {
    if (__reftype(typedbyref) == typeof(T))
        return__refvalue(typedbyref,T);
    else
        throw new InvalidCastException();
}
```

The **\_\_refvalue** operator is implemented using the **refanyvalue** CIL instruction. This instruction requires a type token which could be either a generic type parameter or a specific type. There is an alternative way to dereference a typed reference, which is by using the **GetValueDirect** and **SetValueDirect** instance methods defined in the **System.Reflection.FieldInfo** type. These methods don&#39;t use the **refanyvalue** instruction and they are more powerful because they don&#39;t require a type to access a typed reference. They internally call unmanaged functions in the CLR. I&#39;ll discuss them later in this book together with reflection.

The behavior of **\_\_reftype** is the same as the **GetTargetType** method discussed earlier. The **\_\_makeref** operator accepts a variable of any type except **TypedReference** as discussed in the previous section. The **\_\_refvalue** operator requires that the typed reference is valid and that the specified type is same as the type of the reference. Otherwise, an exception of type **System.InvalidCastException** is thrown.

For practical use cases of **TypedReference** and the relevant Visual C# operators, you can check out how they have been used to implement the **System.ArgIterator.GetNextArg** method group, the [**GenericPtrToStructure**](http://referencesource.microsoft.com/mscorlib/R/6fcd4e4df3e9b91a.html) **\&lt;T\&gt;** and [**GenericStructureToPtr**](file:///../R/101515214610935a.html) **\&lt;T\&gt;** methods defined in **System.Runtime.InteropServices.SafeBuffer** type, the **GetValue** and **SetValue** methods defined in the **System.Array** type, the **System.String.Concat** variadic method, the **WriteLine** and **Write** variadic methods defined in the **System.Console** type, the **Exchange\&lt;T\&gt;** and **CompareExchange\&lt;T\&gt;** methods defined in the **System.Threading.Interlocked** type, and the **System.Runtime.Serialization.ObjectManager.** [**DoValueTypeFixup**](file:///../R/c13190b2213527e3.html) method. I&#39;ll discuss some of these methods in the next section.

### 1.3.5 System.ArgIterator and System.RuntimeArgumentHandle

These two value types enable you to implement methods with a variable number of parameters that are potentially of different types without constraints. This feature is equivalent to C++ variadic methods except that it&#39;s type safe. As you&#39;ll see shortly, this is achieved using typed references. These two types are referred to as **byref-like** types. The **RuntimeArgumentHandle** type is simple and contains only a field of type **IntPtr** that is used to store an opaque handle<sup>7</sup> to the list of arguments<sup>8</sup> of a variadic method. The **ArgIterator** type is used inside a variadic method to iterate over all the optional arguments. These two types can only be used for local variables and parameters. The use of these types for fields, method return values, or the element type of an array is not verifiable. Also, boxing these types is not verifiable<sup>9</sup>. Finally, just like managed pointers and typed references, these types cannot be used as type arguments in generic type instantiations.

An example of a variadic method that uses these types is **String.Concat** which is defined as follows:

```
public static String Concat(Object arg0, Object arg1, Object arg2, Object arg3, __arglist) {

    Object[] objArgs;
    Int32 argCount;
    ArgIterator args = newArgIterator(__arglist);

    // +4 to account for the 4 hard-coded arguments at the beginning of the list.
    argCount = args.GetRemainingCount() + 4;
    
    objArgs = newObject[argCount];

    // Handle the hard-coded arguments
    objArgs[0] = arg0;
    objArgs[1] = arg1;
    objArgs[2] = arg2;
    objArgs[3] = arg3;

    // Walk all of the args in the variable part of the argument list.
    for (Int32 i = 4; i < argCount; i++) {
        objArgs[i] = TypedReference.ToObject(args.GetNextArg());
    }

    // Call another overload of Concat that is not variadic.
    return Concat(objArgs);

}
```

The first four parameters are fixed and the fifth parameter represents a list of optional parameters. The **\_\_arglist** keyword is an undocumented Visual C# keyword and it&#39;s not part of the standard C#. The **\_\_arglist** parameter must come after all fixed parameters and there can only be one such parameter<sup>10</sup>. When compiling this method, its signature in metadata would be:

```
.method public hidebysig static vararg string
        Concat(object arg0,
               object arg1,
               object arg2,
               object arg3) cil managed
```

It&#39;s interesting to note that there is actually no fourth parameter. Instead, a constraint called **vararg** has been applied on the method. This indicates that the method uses the **vararg** calling convention. The CIL instruction **arglist** can be used in such methods to obtain a pointer of type **RuntimeArgumentHandle** to the argument list. The **ArgIterator** constructor that has been used in the C# code accepts this pointer, validates the list and creates an instance of **ArgIterator**. The **arglist** instruction can be used multiple times in the same method to create multiple iterators to the same list of arguments. The pointer that this instruction returns is valid only during the lifetime of the method including methods that it calls. Using the **arglist** instruction in a method that doesn&#39;t have the **vararg** constraint or using the pointer it returns outside the method&#39;s lifetime results in an undefined behavior.

The **ArgIterator** type is defined as follows:

```
public struct ArgIterator {

    public ArgIterator(RuntimeArgumentHandle arglist);
    public unsafe ArgIterator(RuntimeArgumentHandle arglist, void* ptr);
    public TypedReference GetNextArg();
    public TypedReference GetNextArg(RuntimeTypeHandle rth);
    public extern Int32 GetRemainingCount();
    public RuntimeTypeHandle GetNextArgType();
    public void End();
    public override Int32 GetHashCode();
    public override Boolean Equals(Object o);
    
    private IntPtr ArgCookie;               // Cookie from the execution engine.
    private IntPtr sigPtr;                  // Pointer to remaining signature.
    private IntPtr sigPtrLen;               // Remaining length of the pointer.
    private IntPtr ArgPtr;                  // Pointer to remaining arguments.
    private Int32 RemainingArgs;            // Number of remaining arguments.
}
```

There are two constructors, both require the pointer returned from the **arglist** instruction as an argument. This is a pointer to all arguments of the method including the fixed ones. The first constructor will validate the list and initialize the fields accordingly. The **ArgPtr** field will point to the first optional argument and the **RemainingArgs** field will hold the number of arguments that have been passed as optional arguments. The second constructor has another parameter called **ptr** of type **void\***. If this parameter is zero, the **ArgPtr** field will point to the very first argument and the **RemainingArgs** field will hold the total number of arguments. Therefore, **ArgIterator** will provide access to all arguments. If **ptr** is not zero, it&#39;s assumed that it points to one of the arguments<sup>11</sup>. The constructor will initialize the fields so that **ArgPtr** points to the first argument that follows the one pointed to by **ptr**. The **RemainingArgs** field will hold the number of remaining arguments including the one specified by **ArgPtr**.

The **ArgCookie** field points to the same data structure as the one pointed to by the **RuntimeArgumentHandle** that was passed to the constructor. This data structure fully describes all the fixed and optional arguments including their number and types and it&#39;s used to initialize the rest of the fields of **ArgIterator**.

The first **GetNextArg** method retrieves the current argument, advances **ArgPtr** to point to the next argument and decrements **RemainingArgs**. If the **ArgIterator** instance has been default-initialized or if the number of remaining arguments is zero, the method throws an exception of type **System.InvalidOperationExcepion**. Therefore, the **TypedReference** that this method returns will always be valid.

The second **GetNextArg** method is used when the internal data structure that describes the argument list doesn&#39;t describe the types of the arguments<sup>12</sup>. Therefore, you have to specify the types of arguments using the **rth** parameter. If **rth** or **ArgPtr** are zero, an exception of type **ArgumentNullException** is thrown<sup>13</sup>. It&#39;s fully your responsibility to make sure that the iterator doesn&#39;t access past the last argument. The type specified by **rth** is used to compute the number of bytes to advance **ArgPtr** and the type of the resulting typed reference.

The **GetRemainingCount** method returns the number of arguments that can be iterated. The **GetNextArgType** returns the metadata type token of the type of the next argument without advancing the iterator. If the **ArgIterator** instance has been default-initialized, an exception of type **System.NotSupportedException** is thrown<sup>14</sup>. If the number of remaining arguments is zero, an exception of type **InvalidOperationExcepion** is thrown.

The **End** method is supposed to release any resources that have been allocated by the **ArgIterator** instance. This includes any call stack space. It corresponds to **va\_end** in C++. However, the CLR currently doesn&#39;t require this method and therefore it doesn&#39;t do anything. The documentation says that you can use this method to indicate the end of processing the argument list but it&#39;s not clear whether you must use it. I&#39;ve never seen any code that calls this method.

The **GetHashCode** method uses the structure of the argument list to compute the hash code. The Equals method always throws an exception of type **NotSupportedException**. Instances of **ArgIterator** are never considered to be equal.

You can use the following syntax to call a **vararg** method in C#:

```
Concat(fixed1, fixed2, fixed3, fixed4, __arglist(opt1, opt2));
```

If you don&#39;t want to pass any optional arguments, you can call the method as follows:

```
Concat(fixed1, fixed2, fixed3, fixed4, __arglist());
```

Variadic methods that use the **vararg** constraint cannot be members of generic types. It&#39;s not supported by the standard because its use cases are very rare while at the same time hard to implement. All **vararg** methods are not CLS-compliant.

### 1.3.6 Unmanaged Pointer Types

Unmanaged pointers are just like C/C++ pointers. An unmanaged pointer can be defined anywhere, can point to any location and can be arithmetically manipulated in arbitrary ways. They are not reported to the garbage collector. Unmanaged pointers should only be used when interoperating with unmanaged code. Unmanaged pointer types are named in the CTS as **T\*** where **T** can be any type. **T** is called the _referent type_. However, C#, to promote type-safety, doesn&#39;t allow **T** to be an interface type, an object type, a value type that contains references, or a generic type parameter. Unmanaged pointers don&#39;t have type objects or class library types that describe them and are not boxable. Unmanaged pointers are not CLS-compliant.

In the CLR, merely defining variables of unmanaged pointer types produces verifiable code. However, if you use a managed pointer in any way, the CLR verifier will not bother analyzing the code and immediately throws a **VerificationException** exception. C# supports unmanaged pointers.

The CLI specifies the ways in which unmanaged pointers can be used while at the same time preserving type safety. However, it&#39;s fully your responsibility and it&#39;s easy to mess it up. To the best of my knowledge, there are no tools that can help in verifying the type safety of code that uses unmanaged pointers in general.

Unmanaged pointer types cannot be used as type arguments in instantiations of generic types and methods. There is simply no convincing reason that anyone would want to do that.

#### 1.3.6.1 Method Pointer Types

A method pointer is an unmanaged pointer to a function and it holds the address of that function. A method pointer can point to a managed instance method, a managed static method, or unmanaged method. The CLI provides an elegant alternative to methods pointers called _delegates_, which will be discussed in chapter 10. C# doesn&#39;t support method pointers. Delegates are CLS-compliant.

A pointer to an instance method can be created in CIL using the **ldftn** instruction and a pointer to a virtual method can be created using the **ldvirtftn** instruction. The **calli** instruction accepts a method pointer and calls the specified method. Method pointers created using CIL instructions are all typed and are tracked by the verifier to makes sure that they are compatible with the method signature passed to the **calli** instruction. Method pointers can be passed to unmanaged code so that it can call managed methods. For an example of using method pointers in CIL, refer to Section II.4.5 of the CLI.

### 1.3.7 System.Nullable\&lt;T\&gt;

This type is a value type. The CIL instructions that convert between types treat this type in a special way. In particular, the corresponding boxed type of this type is the boxed type of **T**. Note that the generic parameter **T** must be a value type. Otherwise, an exception of type **TypeLoadException** will be thrown during CIL translation. Generic instantiations of this type are called _nullable value types_ or _nullable types_. These types are not boxable themselves<sup>15</sup>. I&#39;ll discuss these types and how conversion instructions treat them in Chapter 5.

### 1.3.8 Generic Types and Generic Type Parameters

Generic types that have unbound generic parameters are not really types but rather type templates. Also, generic type parameters (also called generic parameters) are not really types but rather type placeholders. What this means is that these types cannot be types of values or locations. Something like this cannot be expressed in CIL code or metadata. They are still referred to as types in the CLI and the C# standard. However, it&#39;s expected from you to know the difference. Generics are discussed in Chapter 9.

When defining a variable of a type that is a generic parameter or an open generic type in a method, the method can only be called when all generic parameters have been bound; they have been replaced with type arguments. Otherwise, there is no way to express such method calls in CIL code.

Generic types can be either value types or reference types depending on their definition. However, generic parameters are neither value types nor reference types. For this reason, operations on generic parameters must consider both possibilities. Generic types cannot derive from **System.Attribute** and cannot be used as custom attributes.

### 1.3.9 Boxable Types and Boxed Types

_Boxing_ is the process of converting an instance of a value type to an object of some reference type that is stored in a different location. The result of this process is a reference of type **Object** that identifies the object. _Unboxing_ is the process of determining the address of the value that has been boxed within an object, which can then be followed by a copy operation to produce a value type instance. The result of unboxing is a controlled-mutability managed pointer. The boxing and unboxing operations always ensure type safety. I&#39;ll discuss how these operations work in chapter 3. The purpose if these operations is just like any other conversion operations – to make APIs have broader applicability.

Every value type has a corresponding reference type called the _boxed value type_ or the _boxed type_. A value type is sometimes called in the CLI an _unboxed value type_. A value type definition defines both the value type and its associated boxed type. A value type that has a corresponding boxed value type is called a _boxable type_. A boxed value type is an object type and its instances, called _boxed values_ or _boxed objects_, are objects. Reference types don&#39;t have corresponding boxed types.

A boxed type doesn&#39;t have a name that can be directly used in metadata or CIL<sup>16</sup>. Therefore, you cannot define a variable of a boxed type, inherit from a boxed type, or use boxed types to define custom attributes. Boxed value types are always implicitly sealed. Attempting to load a type derived from a sealed type causes an exception of type **System.TypeLoadException** to be thrown. Boxed enumerated value types are directly derived from **Enum** and all other boxed types are directly derived from **ValueType**. Note that a boxed enumerated type is different from the boxed type of the underlying type.

Boxing can be performed using the **box** CIL instruction. Unboxing can be performed using the **unbox** instruction. Unboxing followed by copying the value can be performed using the **unbox.any** instruction. A boxable type is a type to which the **box** instruction can be applied. Reference types are boxable. Boxing an instance of a reference type simply returns an object reference of the same type to the same object.

Note that instantiated generic types (also called closed generic types) have corresponding boxed types but (partially instantiated) generic types and generic type parameters, although boxable, don&#39;t have corresponding boxed types because they cannot be referred to by name and they are not real types that describe values, making them pointless. The reason that they are boxable is that, at run-time, they will be real types.

The target type of the **unbox** instruction is always a value type. On the other hand, the target type of the **unbox.any** instruction can be any boxable type. When applied to a reference type, the result is an object reference of the target type to the same object. The **unbox.any** instruction is the exact reverse of the **box** instruction.

The **unbox** and **unbox.any** instructions accept a **null** reference only if the target type is a nullable type. Otherwise, an exception of type **System.NullReferenceException** is thrown. The box instruction produces a **null** reference only when the input value is either **null** or an instance of a nullable type whose **HasValue** is false. When performing these operations between incompatible types, an exception of type **System.InvalidCastException** is thrown.

Attempting to box a value of a type that is not boxable in CIL causes an **InvalidProgramException** exception to be thrown during CIL translation.

### 1.3.10 Implicit Types

Implicit types are types that don&#39;t have explicit type definitions. These types are automatically defined by the runtime when they are first used. The mention of an implicit type is in itself a complete definition of the type. The same implicit type that has been used one or more times is defined only once. Implicit types include built-in types, array types, and pointer types. Arrays are discussed in chapter 8. There is no way to inherit from these types. All and only array types derive from **System.Array**.

### 1.3.11 Interface Types

An interface type represents a functional contract that consists of a number of method signatures. An object type can implement an interface to indicate that it supports the contract. A method can have one of its parameters be of an interface type to indicate that it requires the contract. A type can implement zero more or interfaces. To enable this feature, the execution engine has to implement interface implementation in a different way than type inheritance. Interfaces are discussed in chapter 2.

## 1.4 Type Packaging

While there is no such a thing as &quot;type packaging&quot; in the Common Language Infrastructure (CLI), I&#39;ll use this term to discuss how types are organized. _Namespaces_ are used to organize types into logical packages so that each namespace contains types that are related in some meaningful way. But in order for types to be consumed by the CLR, they must be organized into physical packages called _assemblies_. Typically, an assembly is a single Portable Executable (PE) file. I will discuss namespaces and then discuss how they are related to assemblies. I will defer the discussion of assemblies to chapters 14 and 15.

### 1.4.1 Logical Packaging (Namespaces)

Earlier in this chapter, I mentioned many types such as **System.Object** , **System.String** , and **System.Int32**. Each of these names logically consists of two parts. The first part, **System** , is the namespace that **Object** , **Int32** and **String** belong to. The _namespace-qualified type__name_ consists of both the namespace and the type name. Namespaces is a high-level language feature. Different languages may support namespaces in different ways or not provide this feature at all. The CLR does not care about namespaces and uses the namespace-qualified type names or the assembly-qualified type names (defined in chapter 15). The CLI does mention namespaces a couple of times but doesn&#39;t define them.

A namespace is a logical grouping of types. It&#39;s logical because this group is only a group to developers, not to the execution engine. Namespaces don&#39;t have special encoding in metadata or CIL. The main goal of namespaces is to group related types so they can be easily located and used by programmers while at the same time dismissing types that are not needed. For example, what kind of types do you think the namespace **System.IO** is grouping? It&#39;s easy to see that **System.IO** contains all those types that perform input/output operations such as creating, reading, and writing to files. So if you want to read from a file, you can easily and correctly guess that the type that reads from files is in the **System.IO** namespace. **System.Collections** contains those types that represent collections of items such as lists, stacks, queues, and hash tables. **System.Net** contains those types that perform networking operations. The **System** namespace contains the built-in types such as **Int32** , **Object** , **ValueType** , **String** , and **Array**.

When designing class libraries, users of these libraries will certainly appreciate it if you define all exported types in namespaces and follow a number of guidelines for naming namespaces and the types within them. First of all, choose namespace names in the following format:

\&lt;Company\&gt;.(\&lt;Product\&gt;|\&lt;Technology\&gt;)[.\&lt;Feature\&gt;][.\&lt;Subnamespace\&gt;]

The first part of the name is the name of the company that will release these libraries. If you&#39;re a freelancer, you can omit this part. The second part, which is mandatory, is the name of the product or technology that the libraries implement. The third part of the name depends on the types that are grouped under it. Then you can add one or two parts or subnamespaces depending on how complex the library is.

If there are a number of related types but some of them are expected to be used much more often than the others, the less frequently used ones should be grouped in a subnamespace. Also, avoid naming types with names that are the same as namespace names in your libraries or framework libraries. Finally, avoid grouping your types in the same namespaces that are used to group the framework types.

### 1.4.2 Physical Packaging (Assemblies)

An assembly is an executable unit that contains a collection of types and resources. To the runtime, all types must be exposed through assemblies. The .NET framework supports two kinds of assemblies: single-file and multi-file. A single-file assembly consists of a single PE file. A multi-file assembly consists of several files where at least one of them is a PE file, which is the main file of the assembly. Because assemblies can be single-file and multi-file, they are usually defined as logical units of functionality. In most cases, you will be building and using single-file assemblies.

An assembly with **.exe** extension is called an _application<sup>17</sup>  An assembly with **.dll** extension is called a _library_. However, non-Windows .NET Core apps and libraries both have the **.dll** extension by default. An assembly with **.winmd** extension is called a _Windows Runtime metadata file_. An assembly with **.winmdobj** extension is called a _Windows Runtime metadata object file_.  They all have the same physical structure and they all contain CIL code and metadata. The difference is that an application has a managed entry point typically called the **Main** method. In contrast, libraries, Windows metadata files, and Windows metadata object files don&#39;t have an entry point. For this reason, applications can be executed directly whereas libraries and Windows metadata files can only be loaded and executed as referenced assemblies. An assembly might consist of more than one PE file, each of these files is called a module which has an extension **.netmodule** except for the main module which has one of the four extensions mentioned earlier. Assemblies and modules are discussed in Chapter 14.

The .NET framework ships with many assemblies. The core .NET Framework assembly is called **mscorlib.dll** , which contains frequently used types and many other miscellaneous types that don&#39;t fit in other assemblies.  The corresponding .NET Core assembly is called **System.Private.CoreLib.dll**. Other commonly used .NET Framework assemblies include **System.dll** and **System.Core.dll**. **System.dll** exposes many useful types related to diagnostics and networking. **System.Core.dll** provides the basic LINQ types such as **Enumerable** and **Queryable** , the basic DLR types such as **CallSite\&lt;T\&gt;** and **CallSiteBinder** and other types.

There is no structural relation between namespaces and assemblies. Different assemblies can contain types that belong to the same namespace. For example, all of **mscorlib.dll,**** System.dll **, and** System.Core.dll **contain types that belong to the** System.IO **namespace. In addition, the same assembly may contain types that belong to different namespaces. For example,** mscorlib.dll **contains types that belong to many namespaces such as** System **,** System.IO **,** System.Collections **, and** System.Threading.Tasks**. The bottom line is that there is no correspondence between namespaces and assemblies. In order to specify a type unambiguously, it is not enough to specify the namespace-qualified name, the assembly that defines it must also be specified.

## 1.5 Type Safety

The CTS states rules regarding how to define types and how these types are used by CIL instructions. However, the CTS is very powerful. It defines object types whose behavior is well-defined and at the same time, it also defines unmanaged pointers that can be used to change the state of an app in arbitrary ways. It&#39;s not hard to write a malicious program in CIL, inject it or load it in a running app&#39;s process (as a plug-in, for example) and access sensitive data or cause the app to malfunction. To be able to build secure, reliable apps, it&#39;s vital to provide a mechanism that can guarantee that values are only accessed and manipulated as per the CTS rules. This mechanism is called _verification_ and a CIL program that passes verification is called type-safe. A program that fails verification is called _unverifiable_. This mechanism is necessarily conservative, meaning that a program that fails verification is not necessarily type-unsafe. _Type safety_ means that the code can only do what the type system permits.

_Type safety_ is a characteristic of both programming languages and programs. It is formally defined to be a collection of two properties:

- _Preservation_: A type system has this property if and only if every initialized memory location is of a type that is assignment-compatible with the types of the values that are allowed to be stored in it. I believe that all languages except machine languages must support preservation to be of any practical value.
- _Progress_: Each operator is supplied with the right number and types of operands as supported by the operator at the time it is going to execute and the operator and all operands are accessible as defined by the type system. The language defines the behavior of the code in case of violations. That is, execution should not reach a situation where the behavior is undefined.

A language is type-safe if all conforming implementations perform the necessary checks either at compile-time or at run-time (or both) to ensure these two properties. Some type-safe languages, such as C#, provide features that are not checked for type-safety. Of course, in these languages, type safety is only ensured by the compiler and the runtime when none of these features are used. Throughout this book, many examples of type checking will be given. A program is type-safe if it satisfies the two properties above. A program could be type-safe even if it has been written in a type-unsafe language or uses type-unsafe features. In this case, type-safety is ensured by either third-party tools or by manual assessment by the programmer.

I consider _strong typing_ to be the same as preservation. Every value has an exact type and every allocated location is typed. Types of values and locations cannot be spoofed or corrupted. In dynamic typing, the type of the value of a location may change (by changing the value), but the value must always be an instance of the type that it claims to be of. A value can only be stored in a location whose type is assignment-compatible with the type of the value as defined by the type system. For example, an instruction cannot store a value of type **Int64** into a location of type **Int32**. If this happened, the value would spill into neighboring locations, potentially corrupting the state of other locations. Also any operations that later consume that value may not work as expected.

Progress itself consists of three properties:

- _Memory safety_: Only those locations that have been allocated and initialized can be accessed. An access intended for an object or value cannot go to memory outside its boundaries.  An allocated location can be deallocated at most once and only allocated locations can be deallocated. An access intended for an instance cannot be on a deallocated location even if that location happens to be reallocated for a different instance.
- _Code safety_: Access to an instance is only permissible through accessible methods and fields. Calling an instance method is only permissible if it&#39;s defined by the type of the instance receiving the call. Signatures of methods and functions are respected and cannot be spoofed or corrupted. An operation can be performed on a value only if the exact type of the value satisfies the requirements of that operation.
- _Well-defined exception system_: Every situation in which a dynamic type safety check fails triggers a well-defined error behavior.

A program can be type-safe and still be buggy. Type safety and correctness are two completely different properties of code. Type safety is defined by the type system while correctness is defined by the specification of the program. Therefore type-safety does not imply correctness in any way. It has two benefits of critical importance to most software development projects:

- It makes it much easier to write correct code.
- It makes it much easier to debug incorrect code.

The CTS has been designed to promote type safety. While the runtime ensures type safety through verification during CIL translation and during execution, high-level language compilers may also perform some kind of type safety checking as well. Programming languages that support static type checking and static name binding (to some extent) are called statically-typed languages (to the same extent). The languages that favor dynamic type checking and late binding are called dynamically-typed languages. It&#39;s a really spectrum. The .NET framework supports dynamic typing and late binding through the Dynamic Language Runtime (DLR), which will be discussed in depth in chapter 11.  Note that the type **Object** itself is not a dynamic type because it does not support late binding.

### 1.5.1 Compile-Time Type Safety Checking

You can write a program in a high-level language such as C# and run it to see whether every method is going to pass verification. Note that you may have to run the program many times to test all methods. If a method didn&#39;t pass verification, you can examine its code and try to find the type safety violations and fix them. This is inconvenient and makes you less productive. The C# compiler should also statically analyze all the code to find any operations that may violate type safety and report them to you. For example, the following code snippet reads a string from the console and stores a reference to it in the **input** variable, which is of type **String**. If the input string contains no characters, the **temp** variable will be assigned a reference to a boxed **Int32** instance. Otherwise, the **temp** variable will be assigned a reference to a **String** object. This is OK because **temp** is of type **Object** and because both boxed **Int32** and **String** are ultimately derived from **Object**.

```
Object temp;
String input = Console.ReadLine();

if (input.Length == 0)
    temp = 10; // temp contains a reference to a boxed Int32 value.
else
    temp = input; // temp contains a reference to a String object.

String str = temp; // Compiler error.
```

It&#39;s not always possible for the compiler to know for sure whether every operation is type-safe for all input values. In this example, at the last line in the code, the compiler only knows that **temp** is referencing an object either of type boxed **Int32** or **String**. Therefore, it will emit the following error:**Cannot implicitly convert type &#39;object&#39; to &#39;string&#39;. An explicit conversion exists (are you missing a cast?)**.

The compiler is telling you that **temp** is of type **Object** and cannot be assigned to **str** because it&#39;s of type **String**. A **String** reference can only refer to an instance of type **String** or one of its derived types. However, **temp** is of type **Object** and can refer to instances of many other different types such as boxed **Int32**. So if **temp** was referring to a boxed **Int32** instance, the runtime verifier will throw an exception because a **String** reference cannot refer to a boxed **Int32** instance. If **temp** was referring to a **String** instance, the runtime will allow the assignment to execute. But since the compiler doesn&#39;t know for sure that the assignment will succeed, the compiler has emitted an error to inform you that this code might be buggy because the assignment may not always succeed. You can tell the compiler that you know what you&#39;re doing and that you&#39;re aware of the potential issues that might occur by explicitly casting **temp** to type **String**. Even if you added the explicit cast, the CIL translator will emit a dynamic type check to throw an exception if a boxed **Int32** instance is being assigned to a **String** location.

That&#39;s the essence of static type safety checking. It helps you to detect code that may fail at runt-time before even running it for the first time. If the compiler has allowed this code to compile, you may not be aware of this potential bug even if you tested the code because the tests may not try the **Int32** case and always take the **String** case.

The performance overhead of verification during CIL translation is not zero and impacts startup performance. It takes time depending on the size of the CIL method. Therefore, verification is skipped for fully trusted code<sup>18</sup> and for code that has been granted the permission to skip verification. This is another reason why static type checking is important. In addition, the emitted dynamic type checks impact performance and can be skipped using the **no.** instruction prefix<sup>19</sup>. That prefix can only be used when the code is fully trusted or the permission to skip verification has been granted.

C# supports dynamic typing. That is, in the same program, some expressions could be statically typed while other are dynamically typed on which static type safety checking cannot be performed because the type of the value of the expression is not known until run-time. CIL, on the other hand, is purely statically typed<sup>20</sup>. In Chapter 11, I explain how dynamic typing in C# works.

### 1.5.2 Run-Time Type Safety Checking

So what all of this is supposed to mean? Well, type safety is simply great. When enforced, it prevents lots of nasty bugs from occurring on production systems. It turns potential bugs into exceptions during development. There are many features of the CLR that would not be possible without type safety. These include garbage collection, security, AppDomains, and others.

Figure 1‑7: Type safety rings as portrayed in the CLI standard.

Figure 1‑7 demonstrates type safety rings or circles as described by the CLI. Only code that belongs to the most inner ring will successfully pass the runtime verification process and therefore, is provably type-safe. Let&#39;s discuss them in a bit more detail.

_Syntactically correct CIL code_ is code that its syntax is correct according to **ilasm.exe** and can be assembled, but it does not necessarily make sense. Code that belongs to this ring may have a call instruction to a method that is not defined or may create an instance of type that is not instantiable. The following code attempts to access a local variable that has not been defined.

```
.method private hidebysig static void  Main() cil managed
{
    .entrypoint
    // Code size       8 (0x8)
    .maxstack  2
    IL_0000:  nop
    IL_0001:  ldc.i4.0
    IL_0002:  stloc.0
    IL_0003:  ldloc.0
    IL_0004:  ldc.i4.1
    IL_0005:  add
    IL_0006:  stloc.0
    IL_0007:  ret
}
```

This code is syntactically correct but is not semantically correct. So it belongs to the most outer ring, but not to the next one. If you attempt to run such code, an **InvaidProgramException** exception is thrown during CIL translation.

_Valid (correct) CIL code_ is both syntactically correct and semantically correct. Moreover, the associated metadata has to be in the expected format and has to conform to the CTS. However, the code may or may not be type-safe. For example, it uses unmanaged pointers and may spoof or corrupt the types of object references. All compilers should generate code that falls at least in this ring. If you write code directly in CIL, your code might fall in the outer ring. Code that falls in this ring but not in the inner ring is called _type-unsafe code_. The main reason to use such code is to be able to call unmanaged code. Some high-level languages support type-unsafe code such as C# and some don&#39;t such as Visual Basic. But because type-unsafe code is dangerous, it&#39;s allowed to run only in a fully trusted AppDomain or in an AppDomain that has been granted the security permission **SecurityPermission** with the flag **SecurityPermissionFlag.SkipVerification** turned on. Otherwise, a **VerificationException** exception is thrown.

_Type-safe CIL code_is type-safe but may or may not pass verification. In C#, you may write unsafe code (using the **unsafe** qualifier) and manually verify it by yourself that this unsafe code is type-safe. This kind of code falls in this ring, but it may not fall in the most inner ring because it may not pass verification. Code that belongs to this ring but not the inner one is allowed to run only in a fully trusted AppDomain or in an AppDomain that has been granted the security permission **SecurityPermission** with the flag **SecurityPermissionFlag.SkipVerification** turned on. Otherwise, a **VerificationException** exception is thrown. To the runtime, code that doesn&#39;t pass verification is treated as type-unsafe code.Code that is type-safe but not verifiably type-safe is called _unverifiably type-safe code_.

Verifiably type-safe CIL code is code that can pass the verification process and therefore it&#39;s provably type-safe. Visual Basic always emits code that falls in this ring. C# emits code that falls in this ring only if the **/safe** compiler switch has not be specified or the **unsafe** qualifier has not been used. The CIL translator will compile this code without throwing exceptions, but it will still emit any required run-time checks (such as array range checks) and these checks may fail, causing exceptions to be thrown. Note that a CIL instruction that has undefined behavior in specific situations is not verifiable in these situations.

The verification process works at the function granularity and requires any related metadata to be able to verify CIL code. Note that a CIL instruction that is not valid or correct cannot pass verification. Verification by itself is not sufficient to maintain type safety. The CIL translator may have to emit additional machine instructions to maintain type safety. For example, consider the following C# code:

```
static void Foo(Object obj) {
    String str = (String)obj;
    // Other code.
}
```

The C# compiler will happily compile this code since you used explicit casting and emit valid CIL code and metadata. Also, the CIL translator will successfully validate the resulting CIL code and metadata, verify the code, and emit the corresponding machine code. However, in order to make sure that **obj** holds a reference to a **String** , the CIL translator has to emit machine instructions before the assignment to perform this check and thrown an exception if it failed. Such type safety checks are not part of the verification process. Such checks are considered to be part of the functional behavior of CIL instructions and have been documented for each CIL instruction in the CLI.

The minimal verification algorithm is documented in the CLI. However, a conforming implementation can implement a better algorithm in the sense that it accepts more type-safe programs that would be rejected by the standard algorithm. In this case, code targeting such implementation will not be portable. The CLR implements a verification algorithm that is very similar to but not the same as the standard one and will be discussed in detail later in this book.

### 1.5.3 Verifying Assemblies Using the PEVerify.exe Tool

If you&#39;re developing a tool that generates CIL code or metadata and would like to check whether the generated code is verifiably type-safe or the metadata is valid, you can use the **PEVerify.exe** command-line tool. Given an assembly or a module, this tool validates the PE file format, the native stub of the entry point (if exists), the metadata, and the CIL code and verifies the CIL code according to the rules specified in part II and III of the CLI. It can emit a list of all validation and verification errors.

The two most important switches are **/md** and **/il**. If none of these switches are specified, it performs first metadata validation and, if no errors occurred, it performs CIL validation and verification second. If only **/md** is specified, the tool will only validate metadata. If only **/il** is specified, the tool will only validate and verify CIL code of all managed functions. If both switches are specified, both checks are performed even if there were metadata validation errors. In all cases, the first thing this tool does is to load the file and make sure it has a valid PE file format. The **/clock** switch tells the tool to measure the time it took to perform all the checks.

Suppose that you want to validate and verify **System.dll**. You can issue the following command to do that:

```
peverify /clock System.dll > errors.txt
```

I&#39;ve omitted the **/md** and **/il** switches to perform all checks and specified the **/clock** switch to measure running time. I&#39;ve also used the output redirection operator to write all of the output to a text file called **errors.txt**. The output is too long to show here. It shows that metadata is valid and emits a long list of CIL offsets into methods at which unverifiable instructions have been found. One of the errors is:

Microsoft.Win32.SafeNativeMethods::InterlockedCompareExchange][offset 0x00000009][found unmanaged pointer][expected address of Int32] Unexpected type on the stack.

This error indicates that the instruction at offset 0x9 in the **InterlockedCompareExchange** method is loading a value on the evaluation stack that is of a type different from the one the instruction is expecting. By examining the CIL code of the method using **ildasm.exe** , you can see that the actual type is **void\*** but the expected type is **int32&amp;**.

Another error is the following:

System.Collections.Generic.SortedSet`1[T]::CheckUniqueAndUnfoundElements][offset 0x00000062] Instruction cannot be verified.

This error indicates that the instruction at offset 0x62 in the **CheckUniqueAndUnfoundElements** method is using an instruction that is not verifiable. Indeed, this instruction is **localloc** , which allocates memory of a dynamic size from the stack and returns an unmanaged pointer of type **native int** to the first byte.

The **System.dll** assembly is written by Microsoft and has been extensively tested and used over many years. Therefore, even though it contains many unverifiable methods, you can expect that all of them are actually type-safe.

Because I specified the **/clock** switch, at the end of the report, the tool will print the running times:

```
Timing: Total run     2219 msec
        MD Val.cycle  1547 msec
        MD Val.pure   1547 msec
        IL Ver.cycle  672 msec
        IL Ver.pure   672 msec
```

The total running time is a slightly larger than two seconds. **MD Val.cycle** and **IL Ver.cycle** refer to the total running time of metadata validation and CIL validation and verification, respectively. This includes initialization and cleanup. **MD Val.pure** and **IL Ver.pure** are similar except that initialization and cleanup are excluded. Note that if the running time is smaller than one millisecond, it will be shown as zero milliseconds. The **GetTickCount** Windows API is used to measure time.

## Footnotes

(1) Some types do not describe values in any way. In particular, generic type parameters and interfaces are considered to be types but they may not describe values in any way. This might sound like an oxymoron, but the terminology is convenient.

(2) It&#39;s unfortunate that the CLI and the C# standard sometimes use the same terms to define different things. Also, related material on the Internet often uses many terms in ways that are not consistent with either of the standards.

(3) The C# compiler has supported optimizations that are only valid when **True** is represented only as 1. This is inconsistent with the standard and breaks the aliasing between **Boolean** and **bool**. For more information, refer to https://github.com/dotnet/roslyn/issues/14262.

(4) Although useful, the CLI has imposed this restriction. The justification for this is not clear to me. In my opinion, it should&#39;ve been allowed but, at the same time, make it not CLS-compliant so that high-level languages don&#39;t have to provide some strange syntax to support it.

(5) It&#39;s not clear to me why the standard says that managed pointers can be returned from methods but not typed references. It looks like an unintended inconsistency.

(6) The by-reference passing technique also includes passing unmanaged pointers.

(7) It&#39;s implemented as a pointer to a value of an internal unmanaged type that has the same layout as **ArgIterator**.

(8) A variadic method has fixed parameters (also called mandatory parameters) and optional parameters. A caller must pass arguments to all of the fixed parameters but can pass zero or more arguments to the optional parameters. The opaque handle here refers to all arguments.

(9) Recall that heap objects lifetimes are arbitrary while the lifetimes of arguments are scoped by the method.

(10) The type metadata format enforces these restrictions.

(11) Such pointer can be created by applying the dereference operator on one of the fixed parameters. There is no documented way to obtain a pointer to one of the optional parameters.

(12) There are internally two kinds of argument list iterators: the self-typed kind and the untyped kind. The Visual C++ compiler&#39;s **va\_arg** uses the latter. That&#39;s why the number of arguments and the number of remaining arguments are unknown. Just like in C++, the number of arguments has to be passed as a fixed argument. An **ArgItertor** that uses the untyped structure is typically created by marshaling a C++-style argument list ( **va\_list** ). In this, book I&#39;ll be always using the self-typed iterator unless otherwise mentioned.

(13) If **ArgPtr** is zero, the method should throw an **InvalidOperationExcepion** exception. Unfortunately, it throws the wrong type of exception.

(14) An **InvalidOperationExcepion** exception should be thrown instead.

(15) There is no way to express that in CIL. Refer to section 1.3.9 for the definition of boxable types.

(16) This is explicitly stated in I.8.2.4 in the CLI. I&#39;m having a hard time understanding CLS Rule 3 which says that boxed value types are not CLS-compliant. If boxed types cannot be referred to by name, then how can they be defined or used in a high-level language?

(17) This could be a Command-Line Interface (CLI) app, a Windows (GUI) app or a Windows Store app that must be run in an app container.

(18) Starting with .NET 4.0, by default, any app that runs without hosting and any library that loads in its default AppDomain are fully trusted.

(19) The CIL translator will emit code so that the input values to each CIL instruction are checked to determine whether an exception should be thrown as specified in the CLI. An example will be provided later in this chapter to demonstrate this.

(20) A location of type **void\*** is not dynamically-typed because the type describes the value stored at the location at run-time as much as at compile-time.
